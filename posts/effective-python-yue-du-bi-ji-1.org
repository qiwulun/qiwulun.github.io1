# -*- mode: Org; org-download-image-dir: "../images"; -*-
#+TITLE: effective python 阅读笔记1
#+DATE: 2016-12-24 14:21:19 
#+TAGS: reading, books
#+CATEGORY: 
#+LINK: 
#+DESCRIPTION: 
#+LAYOUT : post

http://www.effectivepython.com

* Chapter1: Pythonic Thinking
The Python community has come to use the adjective Pythonic to describe code
that follows a particular style. The idioms of Python have emerged over time
through experience using the language and working with others. This chapter
covers the best way to do the most common things in Python.
Item	1:	Know	Which	Version	of	Python	You’re	Using
Item	2:	Follow	the	PEP	8	Style	Guide
Item	3:	Know	the	Differences	Between	bytes,	str,	and	unicode
Item	4:	Write	Helper	Functions	Instead	of	Complex	Expressions
Item	5:	Know	How	to	Slice	Sequences
Item	6:	Avoid	Using	start,	end,	and	stride	in	a	Single	Slice
Item	7:	Use	List	Comprehensions	Instead	of	map	and	filter
Item	8:	Avoid	More	Than	Two	Expressions	in	List	Comprehensions
Item	9:	Consider	Generator	Expressions	for	Large	Comprehensions
Item	10:	Prefer	enumerate	Over	range
Item	11:	Use	zip	to	Process	Iterators	in	Parallel
Item	12:	Avoid	else	Blocks	After	for	and	while	Loops
Item	13:	Take	Advantage	of	Each	Block	in	try/except/else/finally 
Item	14:	Prefer	Exceptions	to	Returning	None
Item	15:	Know	How	Closures	Interact	with	Variable	Scope
Item	16:	Consider	Generators	Instead	of	Returning	Lists
Item	17:	Be	Defensive	When	Iterating	Over	Arguments
Item	18:	Reduce	Visual	Noise	with	Variable	Positional	Arguments
Item	19:	Provide	Optional	Behavior	with	Keyword	Arguments
Item	20:	Use	None	and	Docstrings	to	Specify	Dynamic	Default	Arguments
Item	21:	Enforce	Clarity	with	Keyword-Only	Arguments

* Chapter	3:	Classes	and	Inheritance

** Item	22:	Prefer	Helper	Classes	Over	Bookkeeping	with	Dictionaries	and	Tuples
 - Avoid	making	dictionaries	with	values	that	are	other	dictionaries	or	long	tuples.
 -	Use	namedtuple	for	lightweight,	immutable	data	containers	before	you	need	the
 flexibility	of	a	full	class.
 - Move	your	bookkeeping	code	to	use	multiple	helper	classes	when	your	internal	state
 dictionaries	get	complicated.

** Item	23:	Accept	Functions	for	Simple	Interfaces	Instead	of	Classes
 Item	24:	Use	@classmethod	Polymorphism	to	Construct	Objects	GenericallyItem	25:	Initialize	Parent	Classes	with	super
 Item	26:	Use	Multiple	Inheritance	Only	for	Mix-in	Utility	Classes
 Item	27:	Prefer	Public	Attributes	Over	Private	Ones
 Item	28:	Inherit	from	collections.abc	for	Custom	Container	Types
 Chapter	4:	Metaclasses	and	Attributes
 Item	29:	Use	Plain	Attributes	Instead	of	Get	and	Set	Methods
   - Define	new	class	interfaces	using	simple	public	attributes,	and	avoid	set	and	get
 methods.
	 - Use	@property	to	define	special	behavior	when	attributes	are	accessed	on	your
 objects,	if	necessary.
	 - Follow	the	rule	of	least	surprise	and	avoid	weird	side	effects	in	your	@property
 methods.
	 - Ensure	that	@property	methods	are	fast;	do	slow	or	complex	work	using	normal
 methods.
 Item	30:	Consider	@property	Instead	of	Refactoring	Attributes
   - I	especially	like	@property	because	it	lets	you	make	incremental	progress	toward	a better	data	model	over	time.	Reading	the	Bucket	example	above,	you	may	have	thought to	yourself,	“fill	and	deduct	should	have	been	implemented	as	instance	methods	inthe	first	place.”	Although	you’re	probably	right	(see	Item	22:	“Prefer	Helper	Classes	Over Bookkeeping	with	Dictionaries	and	Tuples”),	in	practice	there	are	many	situations	in which	objects	start	with	poorly	defined	interfaces	or	act	as	dumb	data	containers.	This happens	when	code	grows	over	time,	scope	increases,	multiple	authors	contribute	without anyone	considering	long-term	hygiene,	etc. @property	is	a	tool	to	help	you	address	problems	you’ll	come	across	in	real-world code.	Don’t	overuse	it.	When	you	find	yourself	repeatedly	extending	@property methods,	it’s	probably	time	to	refactor	your	class	instead	of	further	paving	over	your code’s	poor	design.
    
 Item	31:	Use	Descriptors	for	Reusable	@property	Methods
 Item	32:	Use	__getattr__,	__getattribute__,	and	__setattr__	for	Lazy
 Attributes
 Item	33:	Validate	Subclasses	with	Metaclasses
 Item	34:	Register	Class	Existence	with	Metaclasses
 Item	35:	Annotate	Class	Attributes	with	Metaclasses
 Chapter	5:	Concurrency	and	Parallelism
 Item	36:	Use	subprocess	to	Manage	Child	Processes
 Item	37:	Use	Threads	for	Blocking	I/O,	Avoid	for	Parallelism
 Item	38:	Use	Lock	to	Prevent	Data	Races	in	Threads
 Item	39:	Use	Queue	to	Coordinate	Work	Between	Threads
 Item	40:	Consider	Coroutines	to	Run	Many	Functions	Concurrently
 Item	41:	Consider	concurrent.futures	for	True	Parallelism
 Chapter	6:	Built-in	Modules
 Item	42:	Define	Function	Decorators	with	functools.wraps
 Item	43:	Consider	contextlib	and	with	Statements	for	Reusable	try/finally
 Behavior
 Item	44:	Make	pickle	Reliable	with	copyreg
 Item	45:	Use	datetime	Instead	of	time	for	Local	Clocks
 Item	46:	Use	Built-in	Algorithms	and	Data	Structures
 Item	47:	Use	decimal	When	Precision	Is	Paramount
 Item	48:	Know	Where	to	Find	Community-Built	Modules
 Chapter	7:	Collaboration
 Item	49:	Write	Docstrings	for	Every	Function,	Class,	and	Module
 Item	50:	Use	Packages	to	Organize	Modules	and	Provide	Stable	APIsItem	51:	Define	a	Root	Exception	to	Insulate	Callers	from	APIs
 Item	52:	Know	How	to	Break	Circular	Dependencies
 Item	53:	Use	Virtual	Environments	for	Isolated	and	Reproducible	Dependencies
 Chapter	8:	Production
 Item	54:	Consider	Module-Scoped	Code	to	Configure	Deployment	Environments
 Item	55:	Use	repr	Strings	for	Debugging	Output
 Item	56:	Test	Everything	with	unittest
 Item	57:	Consider	Interactive	Debugging	with	pdb
 Item	58:	Profile	Before	Optimizing
 Item	59:	Use	tracemalloc	to	Understand	Memory	Usage	and	Leaks
** Item	1:	Know	Which	Version	of	Python	You’re	Using
   
** 
-	Python’s syntax makes it all too easy to write single-line expressions that
  are overly complicated and difficult to read.
- Move complex expressions into helper functions, especially if you need to use
  the same logic repeatedly.
-	The if/else expression provides a more readable alternative to using Boolean
  operators like or and and in expressions.
* Chapter	2: Functions
Functions in Python have a variety of extra features that make a programmer’s
life easier. Some are similar to capabilities in other programming languages,
but many are unique to Python. This chapter covers how to use functions to
clarify intention, promote reuse, and reduce bugs.

* Chapter	3:	Classes	and	Inheritance
Python is an object-oriented language. Getting things done in Python often
requires writing new classes and defining how they interact through their
interfaces and hierarchies. This chapter covers how to use classes and
inheritance to express your intended behaviors with objects.

* Chapter	4:	Metaclasses	and	Attributes
Metaclasses and dynamic attributes are powerful Python features. However, they
also enable you to implement extremely bizarre and unexpected behaviors. This
chapter covers the common idioms for using these mechanisms to ensure that you
follow the rule of least surprise.

* Chapter	5:	Concurrency	and	Parallelism
Python	makes	it	easy	to	write	concurrent	programs	that	do	many	different	things
seemingly	at	the	same	time.	Python	can	also	be	used	to	do	parallel	work	through	system
calls,	subprocesses,	and	C-extensions.	This	chapter	covers	how	to	best	utilize	Python	in
these	subtly	different	situations.

* Chapter	6:	Built-in	Modules
Python	is	installed	with	many	of	the	important	modules	that	you’ll	need	to	write	programs.
These	standard	packages	are	so	closely	intertwined	with	idiomatic	Python	that	they	may	as
well	be	part	of	the	language	specification.	This	chapter	covers	the	essential	built-in
modules.

* Chapter	7:	Collaboration
Collaborating	on	Python	programs	requires	you	to	be	deliberate	about	how	you	write	your
code.	Even	if	you’re	working	alone,	you’ll	want	to	understand	how	to	use	modules	written
by	others.	This	chapter	covers	the	standard	tools	and	best	practices	that	enable	people	to
work	together	on	Python	programs.

* Chapter	8:	Production
Python	has	facilities	for	adapting	to	multiple	deployment	environments.	It	also	has	built-in
modules	that	aid	in	hardening	your	programs	and	making	them	bulletproof.	This	chapter
covers	how	to	use	Python	to	debug,	optimize,	and	test	your	programs	to	maximize	quality
and	performance	at	runtime.

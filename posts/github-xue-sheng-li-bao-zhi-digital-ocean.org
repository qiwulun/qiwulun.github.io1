# -*- mode: Org; org-download-image-dir: "../images"; -*-
#+TITLE: Github 学生礼包之 Digital Ocean
#+DATE: 2016-12-15 10:55:07 
#+TAGS: 
#+CATEGORY: 
#+LINK: 
#+DESCRIPTION: 
#+LAYOUT : post


* 初次登录
#+BEGIN_EXAMPLE
ssh root@SERVER_IP_ADDRESS 
#+END_EXAMPLE

如果在创建的时候把公钥放上去了，那么就可以直接登录了
* docker 
** seafile
https://hub.docker.com/r/jenserat/seafile/


This Dockerfile does not really package Seafile 5 for Docker, but provides an environment for running it including startup scripts, including all dependencies for both a SQLite or MySQL (requires external MySQL database, for example in another container) setup.
*** Setup
 The image only prepares the base system and provides some support during installation. Read through the setup manual before setting up Seafile.

 Run the image in a container, exposing ports as needed and making /opt/seafile permanent. For setting seafile up, maintaining its configuration or performing updates, make sure to start a shell. As the image builds on phusion/baseimage, do so by attaching -- /bin/bash as parameter.

 For example, you could use
#+BEGIN_SRC bash
$ mkdir seafile
$ docker run -t -i \
   -p 10001:10001 \
   -p 12001:12001 \
   -p 8000:8000 \
   -p 8080:8080 \
   -p 8082:8082 \
   -v /seafile:/opt/seafile \
   jenserat/seafile -- /bin/bash

#+END_SRC
 Consider using a reverse proxy for using HTTPs.

 After the container is started, run
#+BEGIN_SRC bash
 $ download-seafile 
#+END_SRC 
to download Seafile and prepare setting it up.

 Once downloaded, run
#+BEGIN_SRC bash
 /opt/seafile/seafile-server-5.*/setup-seafile.sh
#+END_SRC
, and go through the setup assistant. Do not change the port and storage location defaults, but change the run command appropriately.

#+BEGIN_SRC bash
 /opt/seafile/seafile-server-latest/seafile.sh
#+END_SRC
 start to start the seafile controller process.

#+BEGIN_SRC bash
/opt/seafile/seafile-server-latest/seahub.sh
#+END_SRC
 start for configuring the web UI.

 If you want, do more configuration of Seafile. You can also already try it out.
 Setting up Seafile is finished, exit the container.

 In case you want to use memcached instead of /tmp/seahub_cache/ add the following to your seahub_settings.py
#+BEGIN_SRC python
 CACHES = {
   'default': {
     'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
     'LOCATION': 'memcached:11211',
   }
 } 
#+END_SRC

 Link your memcached instance to your seafile container by adding --link memcached_container:memcached to your docker run statement.
*** Running Seafile
 Run the image again, this time you probably want to give it a name for using some startup scripts. You will not need an interactive shell for normal operation. The image will autostart the seafile and seahub processes if the environment variable autostart=true is set. A reasonable docker command is

#+BEGIN_SRC bash
 docker run -d \
   --name seafile \
   -p 10001:10001 \
   -p 12001:12001 \
   -p 8000:8000 \
   -p 8080:8080 \
   -p 8082:8082 \
   -v seafile:/opt/seafile \
   -e autostart=true \
   jenserat/seafile 
#+END_SRC
 For proxying Seafile using nginx, enable FastCGI by adding -e fastcgi=true.

 Updates and Maintenance
 The Seafile binaries are stored in the permanent volume /opt/seafile. To update the base system, just stop and drop the container, update the image using docker pull jenserat/seafile and run it again. To update Seafile, follow the normal upgrade process described in the Seafile upgrade manual. download-seafile might help you with the first steps if already updated to the newest version.

 Workaround for Seafile issue #478
 If used in FastCGI mode, like recommended when proxying WebDAV, seafdav only listens on localhost:8080; with consequence that it cannot be exposed. The image has a workaround built-in, which uses socat listening on 0.0.0.0:8080, forwarding to localhost:8081. To use it, modify /opt/seafile/conf/seafdav.conf and change the port to 8081, and restart the container enabling the workaround using -e workaround478=true.
** 安装 Shadowsocks
拉取docker-shadowsocks镜像
拉取docker-shadowsocks镜像镜像安装，从 Docker Hub 仓库拉取命令如下（笔者未使用）

#+BEGIN_SRC bash

docker pull oddrationale/docker-shadowsocks

# 配置docker-shadowsocks
docker run --name shadowsocks -d -p 1080:1080 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 1080 -k yourpasswd -m aes-256-cfb
#+END_SRC

输入如下命令：

其中，

 - =-d= ——容器启动后会进入后台
 - =-p= （第一个）——指定要映射的端口，使用的格式是hostPort:containerPort，即本地的 54285 端口映射到容器的 54285 端口
 - =-s= ——服务器IP
 - =-p= （第二个）——代理端口
 - =yourpasswd= ——你的密码
 - =-m= ——加密方式
* Shadowsocks 
** 服务端配置
#+BEGIN_EXAMPLE
sudo apt install shadowsocks
#+END_EXAMPLE

#+BEGIN_SRC javascript
{
"server":"0.0.0.0",
"server_port":5080,
"local_address": "127.0.0.1",
"local_port":5080,
"password":"password",
"timeout":600,
"method":"aes-256-cfb",
"fast_open": true
}
#+END_SRC
启动ss服务：
=ssserver -c /etc/shadowsocks.json=

配置ss服务随系统启动：
$ sudo vim /etc/rc.local
在exit 0前加入一行：
ss-server -c /etc/config.json



** Ubuntu 客户端设置
#+BEGIN_EXAMPLE
sudo apt-get install python-pip
sudo pip install shadowsocks
#+END_EXAMPLE

比如 sslocal -s 11.22.33.44 -p 50003 -k "123456" -l 1080 -t 600 -m aes-256-cfb

-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加""）, -t超时默认300,-m是加密方法默认aes-256-cfb，

为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。

我们可以在/home/mudao/ 下新建个文件shadowsocks.json  (mudao是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：

#+BEGIN_SRC javascript
{
"server": "11.22.33.44",
"server_port":5080,
"local_port":5080,
"password":"password",
"timeout":600,
"method":"aes-256-cfb"
}
#+END_SRC


server  你服务端的IP，服务端可以写成0.0.0.0
servier_port  你服务端的端口
local_port  本地端口，一般默认1080
passwd  ss服务端设置的密码
timeout  超时设置 和服务端一样
method  加密方法 和服务端一样

确定上面的配置文件没有问题，然后我们就可以在终端输入
=sslocal -c /path/to/shadowsocks.json= 回车运行。

** chrome 设置
Switch Omega 中新建情景模式 ── 代理服务器 ── 代理协议:socks 5 地址 127.0.0.1 端口

*** 自动切换
规则列表规则 Shadowsocks

规则列表地址 https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt
** 后台启动

如果你上面可以代理上网了可以进行这一步，之前我让你不要关掉终端，因为关掉终端的时候代理就随着关闭了，之后你每次开机或者关掉终端之后，下次你再想用代理就要重新在终端输入这样的命令 sslocal  -c /home/mudao/shadowsocks.json ，挺麻烦是不？

我们现在可以在你的ubuntu上安装一个叫做supervisor的程序来管理你的sslocal启动。关于supervisor更多点击这

sudo apt-get install supervisor

安装好后我们可以在/etc/supervisor/目录下找到supervisor.conf配置文件，我们可以用以下命令来编辑

sudo gedit /etc/supervisor/supervisor.conf

在这个文件的最后加上以下内容

[program:shadowsocks]
command=sslocal -c /home/mudao/shadowsocks.json
autostart=true
autorestart=true
user=root
log_stderr=true
logfile=/var/log/shadowsocks.log

当然在16.04里你可以直接在/etc/supervisor/conf.d/下新建个文件比如ss.conf然后加入上面内容。

command = 这里json文件的路径根据你的文件路径来填写。确认无误后记得保存。sslocal 和ssserver这两个命令是被存在 /usr/local/bin/下面的，我们要拷贝一份命令文件到/bin

 sudo cp /usr/local/bin/sslocal /bin  (注意空格)

注意：16.04 命令在 /usr/bin/下所以就用

sudo cp /usr/bin/sslocal /bin  (注意空格)

现在关掉你之前运行sslocal命令的终端，再打开终端输入sudo service supervisor restart 然后去打开浏览器看看可不可以继续代理上网。你也可以用ps -ef|grep sslocal命令查看sslocal是否在运行。

这个时候我们需要在/etc下编辑一个叫rc.local的文件 ，让supervisor开机启动。

sudo gedit /etc/rc.local 

在这个配置文件的exit 0前面一行加上 service supervisor start 保存。看你是否配置成功你可以在现在关机重启之后直接打开浏览器看是否代理成功。
** 使用proxychains-ng实现终端代理
=sudo apt install proxychains=
*** 配置
 编辑配置文件 vim /etc/proxychains.conf

 在 [ProxyList] 下面（也就是末尾）加入代理类型，代理地址和端口

 例如使用 TOR 代理，注释掉原来的代理并添加 =socks5 127.0.0.1 1080=
*** 测试
 proxychains4 curl google.com

 注意：proxychains支持的是socks，http, https协议.它们以tcp或者udp协议为基础, ping命令用的是 ICMP 协议， proxychains 不支持;
*** 优化 alias

 alias pc="proxychains4"
*** 使用 =proxychains emacs=
     这样在下面就可以使用 google translate 了
* seafile
https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-seafile-on-an-ubuntu-12-04-vps

#+TITLE: python 运行时间分析
#+DATE: 2016-11-15 17:00:43 
#+TAGS: 
#+CATEGORY: 
#+LINK: 
#+DESCRIPTION: 
#+LAYOUT : post


谁快谁慢

假设有一个字符串，想将里面的空格替换为字符‘-’，用python实现起来很简单，下面是四种方案：
#+HTML: <!--TEASER_END-->

#+BEGIN_SRC python
def slowest_replace(orignal_str):
    replace_list = []
    for i, char in enumerate(orignal_str):
        c = char if char != " " else "-"
        replace_list.append(c)
    return "".join(replace_list)
def slow_replace(orignal_str):
    replace_str = ""
    for i, char in enumerate(orignal_str):
        c = char if char != " " else "-"
        replace_str += c
    return replace_str
def fast_replace(orignal_str):
    return "-".join(orignal_str.split())
def fastest_replace(orignal_str):
    return orignal_str.replace(" ", "-") 
#+END_SRC


时间断点

最直接的想法是在开始 replace 函数之前记录时间，程序结束后再记录时间，计算时间差即为程序运行时间。python提供了模块 time，其中 time.clock() 在Unix/Linux下返回的是CPU时间(浮点数表示的秒数)，Win下返回的是以秒为单位的真实时间(Wall-clock time)。

由于替换函数耗时可能非常短，所以这里考虑分别执行 100000次，然后查看不同函数的效率。我们的性能分析辅助函数如下：


#+BEGIN_SRC python
def _time_analyze_(func):
    from time import clock
    start = clock()
    for i in range(exec_times):
        func()
    finish = clock()
    print "{:<20}{:10.6} s".format(func.__name__ + ":", finish - start)
#+END_SRC

#+BEGIN_SRC python
class Timer(object):
    def __init__(self, verbose=False):
        self.verbose = verbose
    def __enter__(self):
        self.start = clock()
        return self
    def __exit__(self, *args):
        self.end = clock()
        self.secs = self.end - self.start
        self.msecs = self.secs * 1000  # millisecs
        if self.verbose:
            print 'elapsed time: %f ms' % self.msecs

# Use case
if __name__ == "__main__":
    orignal_str = "Profiling a Python program is doing a dynamic analysis"\
        "that measures the execution time of the program and"\
        "everything that compose it."

    with Timer() as t:
        replace_str = ""
        for i, char in enumerate(orignal_str * 10000):
            c = char if char != " " else "-"
            replace_str += c
    print t.secs

#+END_SRC


* timeit

$ python -m timeit -n 1000000 '"I like to reading.".replace(" ", "-")'

1000000 loops, best of 3: 0.253 usec per loop

$ python -m timeit -s 'orignal_str = "I like to reading."' '"-".join(orignal_str.split())'

1000000 loops, best of 3: 0.53 usec per loop

具体参数使用可以用命令 python -m timeit -h 查看帮助。使用较多的是下面的选项：

-s S, –setup=S: 用来初始化statement中的变量，只运行一次；
-n N, –number=N: 执行statement的次数，默认会选择一个合适的数字；
-r N, –repeat=N: 重复测试的次数，默认为3；

* Python 接口

可以用下面的程序测试四种 replace函数的运行情况（完整的测试程序可以在 gist 上找到）：
#+BEGIN_SRC python
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# @Last Modified time: 2016-06-13 20:00:34
orignal_str = "Profiling a Python program is doing a dynamic analysis"\
    "that measures the execution time of the program and"\
    "everything that compose it."
exec_times = 100000


# @profile
def slowest_replace():
    replace_list = []
    for i, char in enumerate(orignal_str):
        c = char if char != " " else "-"
        replace_list.append(c)
    return "".join(replace_list)


# @profile
def slow_replace():
    replace_str = ""
    for i, char in enumerate(orignal_str):
        c = char if char != " " else "-"
        replace_str += c
    return replace_str


def fast_replace():
    return "-".join(orignal_str.split())


def fastest_replace():
    return orignal_str.replace(" ", "-")


def test_equal():
    return slow_replace() == fast_replace() == fastest_replace() == slowest_replace()


def _time_analyze_(func):
    from time import clock
    start = clock()
    for i in range(exec_times):
        func()
    finish = clock()
    print "{:<20}{:10.6} s".format(func.__name__ + ":", finish - start)


def simple_profile():
    print "*" * 40, "\nSimple time analyze"
    for fun in [slowest_replace, slow_replace, fast_replace, fastest_replace]:
        _time_analyze_(fun)


def _timeit_analyze_(func):
    from timeit import Timer
    t1 = Timer("%s()" % func.__name__, "from __main__ import %s" % func.__name__)
    print "{:<20}{:10.6} s".format(func.__name__ + ":", t1.timeit(exec_times))


def timeit_profile():
    print "*" * 40, "\nModule timeit analyze"
    for fun in [slowest_replace, slow_replace, fast_replace, fastest_replace]:
        _timeit_analyze_(fun)


if __name__ == "__main__":
    assert(test_equal())
    simple_profile()
    timeit_profile()
#+END_SRC

Python的timeit提供了 timeit.Timer() 类，类构造方法如下：

1
Timer(stmt='pass', setup='pass', timer=<timer function>)
其中：

stmt: 要计时的语句或者函数；
setup: 为stmt语句构建环境的导入语句；
timer: 基于平台的时间函数(timer function)；
Timer()类有三个方法：

timeit(number=1000000): 返回stmt执行number次的秒数(float)；
repeat(repeat=3, number=1000000): repeat为重复整个测试的次数，number为执行stmt的次数，返回以秒记录的每个测试循环的耗时列表；
print_exc(file=None): 打印stmt的跟踪信息。
此外，timeit 还提供了另外三个函数方便使用，参数和 Timer 差不多。

1
2
3
timeit.timeit(stmt='pass', setup='pass', timer=<default timer>, number=1000000)
timeit.repeat(stmt='pass', setup='pass', timer=<default timer>, repeat=3, number=1000000)
timeit.default_timer()
profile

以上方法适用于比较简单的场合，更复杂的情况下，可以用标准库里面的profile或者cProfile，它可以统计程序里每一个函数的运行时间，并且提供了可视化的报表。大多情况下，建议使用cProfile，它是profile的C实现，适用于运行时间长的程序。不过有的系统可能不支持cProfile，此时只好用profile。

可以用下面程序测试 timeit_profile() 函数运行时间分配情况。

1
2
3
4
import cProfile
from time_profile import *
cProfile.run("timeit_profile()")
这样的输出可能会很长，很多时候我们感兴趣的可能只有耗时最多的几个函数，这个时候先将cProfile 的输出保存到诊断文件中，然后用 pstats 定制更加有好的输出（完整代码在 gist 上）。

1
2
3
4
cProfile.run("timeit_profile()", "timeit")
p = pstats.Stats('timeit')
p.sort_stats('time')
p.print_stats(6)
输出结果如下：

pstats 输出
pstats 输出

如果觉得 pstats 使用不方便，还可以使用一些图形化工具，比如 gprof2dot 来可视化分析 cProfile 的诊断结果。

vprof

vprof 也是一个不错的可视化工具，可以用来分析 Python 程序运行时间情况。如下图：

vprof 性能诊断
vprof 性能诊断

line_profiler

上面的测试最多统计到函数的执行时间，很多时候我们想知道函数里面每一行代码的执行效率，这时候就可以用到 line_profiler 了。

line_profiler 的使用特别简单，在需要监控的函数前面加上 @profile 装饰器。然后用它提供的 kernprof -l -v [source_code.py] 行进行诊断。下面是一个简单的测试程序 line_profile.py：

1
2
3
4
5
from time_profile import slow_replace, slowest_replace
for i in xrange(10000):
    slow_replace()
    slowest_replace()
运行后结果如下：

line_profiler 使用示例
line_profiler 使用示例

输出每列的含义如下：

Line #: 行号
Hits: 当前行执行的次数.
Time: 当前行执行耗费的时间，单位为 “Timer unit:”
Per Hit: 平均执行一次耗费的时间.
% Time: 当前行执行时间占总时间的比例.
Line Contents: 当前行的代码
line_profiler 执行时间的估计不是特别精确，不过可以用来分析当前函数中哪些行是瓶颈。

更多阅读

A guide to analyzing Python performance
timeit – Time the execution of small bits of Python code
Profiling Python using cProfile: a concrete case
profile, cProfile, and pstats – Performance analysis of Python programs.
How can you profile a Python script?
检测Python程序执行效率及内存和CPU使用的7种方法
代码优化概要
Python性能优化的20条建议

本文标题为：Python 性能分析大全

本文链接为：http://selfboot.cn/2016/06/13/python_performance_analysis/

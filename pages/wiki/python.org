# -*- mode: Org; org-download-image-dir: "../../images"; -*-
#+BEGIN_COMMENT
.. title: python
.. slug: python
#+END_COMMENT

* Awesome Python

https://github.com/CodementorIO/Python-Learning-Resources
* IDE
 pycharm
* 在线编程
- PythonTip
   http://www.pythontip.com/coding/code_oj
- lintcode
   http://www.lintcode.com/zh-cn/problem/
* comic

#+DOWNLOADED: http://sophai.github.io/arch_2013/files_2013/Coding/python_comic/02_img.jpg @ 2017-01-10 10:53:23
[[file:../../images/comic/02_img_2017-01-10_10-53-23.jpg]]

#+DOWNLOADED: http://sophai.github.io/arch_2013/files_2013/Coding/python_comic/01_python.png @ 2017-01-10 10:55:35
[[file:../../images/comic/01_python_2017-01-10_10-55-35.png]]
* 应用
** Python HTTP 服务

=python -m http.server=

4. SimpleHTTPServer。最简单地HTTP Server实现。不使用Web框架，一句：
python -m SimpleHTTPServer PORT
就可以运行起来静态服务。平时用它预览和下载文件太方便了。

** 文件 IO
*** Numpy
You can use seek with a file object in the normal way, and then use this file object in fromfile. Here's a full example:

#+BEGIN_SRC python

import numpy as np
import os

data = np.arange(100, dtype=np.int)
data.tofile("temp")  # save the data

f = open("temp", "rb")  # reopen the file
f.seek(256, os.SEEK_SET)  # seek

x = np.fromfile(f, dtype=np.int)  # read the data into numpy
print x 
# [64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88
# 89 90 91 92 93 94 95 96 97 98 99]


#+END_SRC

写个函数看
#+BEGIN_SRC python
def load_data(path, height=128, width=128, dtype=np.uint16):
    with open(path, "rb") as f:
        f.seek(256, os.SEEK_SET)  # seek
        x = np.fromfile(f, dtype=dtype, count=height*width) # read the data into numpy

    return np.reshape(x, (height, width))
#+END_SRC
*** tar 打包
#+BEGIN_SRC python
  from shutil import make_archive
  make_archive('archive_xxx', 'bztar')
  # Out: 'archive_xxx.tar.bz2'
#+END_SRC
*** 遍历

4. glob。 文件名的shell模式匹配，你不用遍历整个目录判断每个文件是不是符合，使用glob一句话就解决。
** 任务调度
你可能接触过定时任务（crontab）

   它管理的任务很规矩，到点执行（当然精确度不那么高）。现在设想你有更复杂的任务需求：这个任务是动态的，也就是不一定啥时候就来排上队约定一个事件等着执行。这时候你可以想，这可以使用队列（Queue模块）啊，嗯也不错。难度再提高：加上优先级策略并能取消某个指定的已经放入队列的任务。现在思考下，这个怎么实现？其实很多工程实践的最好范例都在标准库中。sched模块中的scheduler类就是一个这样的通用的事件调度类。你可以学习它的实现。你问我它的实现多复杂？整个模块加上大幅的注释才134行。
** 系统交互
1. argparse。 用来替代optparse的命令行解析库。如果你考虑用更直观的，推荐docopt，它使用docstring所见即所得实现命令行解析。

2. subprocess。 如果你还被某些书籍引导使用os.system或者os.popen等模块，现在是放弃它们的时候了，这个模块会满足你绝大多数的系统命令执行、执行结果获取和解析等需求。其中最有用的是call（执行系统命令）、check_call（执行结果不为0则抛出异常）、check_output（最方便的获取执行的输出的函数）、Popen+PIPE（支持管道的多命令执行）。

3. os。应该是日常工作最常用的模块了，你是否了解它里面所有的函数和实现呢？举个例子，获取环境变量，我之前这样用：
In : os.environ.get('PYTHONPATH')
读完源码之后我学了一招：
os.getenv('PYTHONPATH')
好吧，省了5个字符。


* 数据类型 
2. collections。 包含了一些额外的数据类型。其中的OrderedDict（有序列的字典）、defaultdict（带有默认值的字典）、namedtuple（通过创建带有字段属性的元组子类）和deque（高效实现插入和删除操作的双向列表）非常常用。

* 函数

3. functools。 这个模块有一些非常有用的工具，其中的partial（偏函数）、wraps（将被包装函数的信息拷贝过来）、total_ordering（只需要定义2个__XX__方法就可实现对象对比的类装饰器）、cmp_to_key（将老式的比较函数转化为关键字函数）非常常用。 

* 异常处理
捕捉异常可以使用try/except语句。
try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。
如果你不想在异常发生时结束你的程序，只需在try里捕获它。
语法：

#+BEGIN_EXAMPLE
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生 
finally:
#+END_EXAMPLE


如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。
* 装饰器
** 上下文管理 
 装饰器contextmanager+yield的docstring清楚地不能再清楚了：

 #+BEGIN_SRC python
   # Typical usage: 
   #     @contextmanager
   #     def some_generator(<arguments>):
   #         <setup>
   #         try:
   #             yield <value>
   #         finally:
   #             <cleanup>

   # This makes this:

   #     with some_generator(<arguments>) as <variable>:
   #         <body>

   # equivalent to this: 

   #     <setup>
   #     try:
   #         <variable> = <value>
   #         <body>
   #     finally:
   #         <cleanup>

 #+END_SRC



* 多进程多线程

** 通用写法
multiprocessing.dummy replicates the API of multiprocessing but is no more than a wrapper around the threading module.

恍然大悟！！！如果分不清任务是CPU密集型还是IO密集型，我就用如下2个方法分别试：

#+BEGIN_SRC python
from multiprocessing import Pool
from multiprocessing.dummy import Pool
#+END_SRC

哪个速度快就用那个。从此以后我都尽量在写兼容的方式，这样在多线程/多进程之间切换非常方便。
** 相关模块
7. Queue。这个模块用于多线程编程，它是一个线程安全的FIFO（先进先出）的队列实现。如果是多进程编程，选用multiprocessing.queues中的Queue、SimpleQueue、JoinableQueue这三个队列实现。 
5. multiprocessing。多进程模块，这重要性就不说了。
10. threading。多线程模块，重要性也不必说。


* 与 C 进行交互

** Python调用C/C++（使用SWIG）
作者：Jerry Jho
链接：https://www.zhihu.com/question/23003213/answer/56121859
来源：知乎

除了SWIG，市面上还有若干用于Python扩展的工具包，比较知名的还有Boost.Python、SIP等，此外，Cython由于可以直接集成C/C++代码，并方便的生成Python模块，故也可以完成扩展Python的任务。

SWIG的一个优势，它不仅可以用于Python，也可以用于其他语言。如今SWIG已经支持C/C++的好基友Java，主流脚本语言Python、Perl、Ruby、PHP、JavaScript、tcl、Lua，还有Go、C#，以及R。SWIG是基于配置的，也就是说，原则上一套配置改变不同的编译方法就能适用各种语言（当然，这是理想情况了……）

用SWIG扩展Python，你需要有一个待扩展的C/C++库。这个库有可能是你自己写的，也有可能是某个项目提供的。这里举一个不浮夸的例子：希望在Python中用到SSE4指令集的CRC32指令。

 首先打开指令集的文档：https://software.intel.com/en-us/node/514245

 可以看到有6个函数。分析6个函数的原型，其参数和返回值都是简单的整数。于是书写SWIG的配置文件（为了简化起见，未包含2个64位函数）：
#+BEGIN_EXAMPLE
 /* File: mymodule.i */
 %module mymodule

 %{
 #include "nmmintrin.h"
 %}

 int _mm_popcnt_u32(unsigned int v);
 unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v);
 unsigned int _mm_crc32_u16(unsigned int crc, unsigned short v);
 unsigned int _mm_crc32_u32(unsigned int crc, unsigned int v); 
#+END_EXAMPLE

接下来使用SWIG将这个配置文件编译为所谓Python Module Wrapper

=swig -python mymodule.i=

 得到一个 mymodule_wrap.c和一个mymodule.py。把它编译为Python扩展：

#+BEGIN_EXAMPLE
 Windows：

 cl /LD mymodule_wrap.c /o _mymodule.pyd -IC:\Python27\include C:\Python27\libs\python27.lib

 Linux：

 gcc -fPIC -shared mymodule_wrap.c -o _mymodule.so -I/usr/include/python2.7/ -lpython2.7
#+END_EXAMPLE
 注意输出文件名前面要加一个下划线。

 现在可以立即在Python下使用这个module了：

#+BEGIN_SRC python
 >>> import mymodule
 >>> mymodule._mm_popcnt_u32(10)
 2 
#+END_SRC
 回顾这个配置文件分为3个部分：
 - 定义module名称mymodule，通常，module名称要和文件名保持一致。
 - %{ %} 包裹的部分是C语言的代码，这段代码会原封不动的复制到mymodule_wrap.c
 - 欲导出的函数签名列表。直接从头文件里复制过来即可。

 还记得本文第2节的那个great_function吗？有了SWIG，事情就会变得如此简单：

#+BEGIN_SRC c
 /* great_module.i */
 %module great_module
 %{
 int great_function(int a) {
     return a + 1;
 }
 %}
 int great_function(int a); 
#+END_SRC

换句话说，SWIG自动完成了诸如Python类型转换、module初始化、导出代码表生成的诸多工作。


 对于C++，SWIG也可以应对。例如以下代码有C++类的定义：

#+BEGIN_SRC c
 //great_class.h
 #ifndef GREAT_CLASS
 #define GREAT_CLASS
 class Great {
     private:
         int s;
     public:
         void setWall (int _s) {s = _s;};
         int getWall () {return s;};
 };
 #endif // GREAT_CLASS 
#+END_SRC
对应的SWIG配置文件

#+BEGIN_EXAMPLE
 /* great_class.i */
 %module great_class
 %{
 #include "great_class.h"
 %}
 %include "great_class.h" 
#+END_EXAMPLE
这里不再重新敲一遍class的定义了，直接使用SWIG的%include指令

 SWIG编译时要加-c++这个选项，生成的扩展名为cxx

#+BEGIN_EXAMPLE
 swig -c++ -python great_class.i 

 Windows下编译：
 cl /LD great_class_wrap.cxx /o _great_class.pyd -IC:\Python27\include C:\Python27\libs\python27.lib
 Linux，使用C++的编译器

 g++ -fPIC -shared great_class_wrap.cxx -o _great_class.so  -I/usr/include/python2.7/ -lpython2.7 
#+END_EXAMPLE

在Python交互模式下测试：
#+BEGIN_SRC python
 >>> import great_class
 >>> c = great_class.Great()
 >>> c.setWall(5)
 >>> c.getWall()
 5 
#+END_SRC

也就是说C++的class会直接映射到Python class

 SWIG非常强大，对于Python接口而言，简单类型，甚至指针，都无需人工干涉即可自动转换，而复杂类型，尤其是自定义类型，SWIG提供了typemap供转换。而一旦使用了typemap，配置文件将不再在各个语言当中通用。


 写在最后：
 由于CPython自身的结构设计合理，使得Python的C/C++扩展非常容易。如果打算快速完成任务，Cython（C/C++调用Python）和SWIG（Python调用C/C++）是很不错的选择。但是，一旦涉及到比较复杂的转换任务，无论是继续使用Cython还是SWIG，仍然需要学习Python源代码。


* python 风格规范 google 开源项目
** 字符串


 即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定.

 Yes:
#+BEGIN_SRC python
  x = a + b
  x = '%s, %s!' % (imperative, expletive)
  x = '{}, {}!'.format(imperative, expletive)
  x = 'name: %s; score: %d' % (name, n)
  x = 'name: {}; score: {}'.format(name, n) 
#+END_SRC
 No:
#+BEGIN_SRC python
  x = '%s%s' % (a, b)  # use + in this case
  x = '{}{}'.format(a, b)  # use + in this case
  x = imperative + ', ' + expletive + '!'
  x = 'name: ' + name + '; score: ' + str(n)
#+END_SRC


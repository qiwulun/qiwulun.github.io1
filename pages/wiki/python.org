# -*- mode: Org; org-download-image-dir: "../../images"; -*-
#+BEGIN_COMMENT
.. title: python
.. slug: python
#+END_COMMENT

* Awesome Python

https://github.com/CodementorIO/Python-Learning-Resources
* IDE
 pycharm
* 在线编程
- PythonTip
   http://www.pythontip.com/coding/code_oj
- lintcode
   http://www.lintcode.com/zh-cn/problem/
* comic

#+DOWNLOADED: http://sophai.github.io/arch_2013/files_2013/Coding/python_comic/02_img.jpg @ 2017-01-10 10:53:23
[[file:../../images/comic/02_img_2017-01-10_10-53-23.jpg]]

#+DOWNLOADED: http://sophai.github.io/arch_2013/files_2013/Coding/python_comic/01_python.png @ 2017-01-10 10:55:35
[[file:../../images/comic/01_python_2017-01-10_10-55-35.png]]
* 应用
** Python HTTP 服务

=python -m http.server=

4. SimpleHTTPServer。最简单地HTTP Server实现。不使用Web框架，一句：
python -m SimpleHTTPServer PORT
就可以运行起来静态服务。平时用它预览和下载文件太方便了。

** 文件 IO
*** Numpy
You can use seek with a file object in the normal way, and then use this file object in fromfile. Here's a full example:

#+BEGIN_SRC python

import numpy as np
import os

data = np.arange(100, dtype=np.int)
data.tofile("temp")  # save the data

f = open("temp", "rb")  # reopen the file
f.seek(256, os.SEEK_SET)  # seek

x = np.fromfile(f, dtype=np.int)  # read the data into numpy
print x 
# [64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88
# 89 90 91 92 93 94 95 96 97 98 99]


#+END_SRC

写个函数看
#+BEGIN_SRC python
def load_data(path, height=128, width=128, dtype=np.uint16):
    with open(path, "rb") as f:
        f.seek(256, os.SEEK_SET)  # seek
        x = np.fromfile(f, dtype=dtype, count=height*width) # read the data into numpy

    return np.reshape(x, (height, width))
#+END_SRC
*** tar 打包
#+BEGIN_SRC python
  from shutil import make_archive
  make_archive('archive_xxx', 'bztar')
  # Out: 'archive_xxx.tar.bz2'
#+END_SRC
*** 遍历

4. glob。 文件名的shell模式匹配，你不用遍历整个目录判断每个文件是不是符合，使用glob一句话就解决。
** 任务调度
你可能接触过定时任务（crontab）

   它管理的任务很规矩，到点执行（当然精确度不那么高）。现在设想你有更复杂的任务需求：这个任务是动态的，也就是不一定啥时候就来排上队约定一个事件等着执行。这时候你可以想，这可以使用队列（Queue模块）啊，嗯也不错。难度再提高：加上优先级策略并能取消某个指定的已经放入队列的任务。现在思考下，这个怎么实现？其实很多工程实践的最好范例都在标准库中。sched模块中的scheduler类就是一个这样的通用的事件调度类。你可以学习它的实现。你问我它的实现多复杂？整个模块加上大幅的注释才134行。
** 系统交互
1. argparse。 用来替代optparse的命令行解析库。如果你考虑用更直观的，推荐docopt，它使用docstring所见即所得实现命令行解析。

2. subprocess。 如果你还被某些书籍引导使用os.system或者os.popen等模块，现在是放弃它们的时候了，这个模块会满足你绝大多数的系统命令执行、执行结果获取和解析等需求。其中最有用的是call（执行系统命令）、check_call（执行结果不为0则抛出异常）、check_output（最方便的获取执行的输出的函数）、Popen+PIPE（支持管道的多命令执行）。

3. os。应该是日常工作最常用的模块了，你是否了解它里面所有的函数和实现呢？举个例子，获取环境变量，我之前这样用：
In : os.environ.get('PYTHONPATH')
读完源码之后我学了一招：
os.getenv('PYTHONPATH')
好吧，省了5个字符。


* 数据类型 
2. collections。 包含了一些额外的数据类型。其中的OrderedDict（有序列的字典）、defaultdict（带有默认值的字典）、namedtuple（通过创建带有字段属性的元组子类）和deque（高效实现插入和删除操作的双向列表）非常常用。

* 函数

3. functools。 这个模块有一些非常有用的工具，其中的partial（偏函数）、wraps（将被包装函数的信息拷贝过来）、total_ordering（只需要定义2个__XX__方法就可实现对象对比的类装饰器）、cmp_to_key（将老式的比较函数转化为关键字函数）非常常用。 

* 异常处理
捕捉异常可以使用try/except语句。
try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。
如果你不想在异常发生时结束你的程序，只需在try里捕获它。
语法：

#+BEGIN_EXAMPLE
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生 
finally:
#+END_EXAMPLE


如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。
* 装饰器
** 上下文管理 
 装饰器contextmanager+yield的docstring清楚地不能再清楚了：

 #+BEGIN_SRC python
   # Typical usage: 
   #     @contextmanager
   #     def some_generator(<arguments>):
   #         <setup>
   #         try:
   #             yield <value>
   #         finally:
   #             <cleanup>

   # This makes this:

   #     with some_generator(<arguments>) as <variable>:
   #         <body>

   # equivalent to this: 

   #     <setup>
   #     try:
   #         <variable> = <value>
   #         <body>
   #     finally:
   #         <cleanup>

 #+END_SRC



* 多进程多线程

** 通用写法
multiprocessing.dummy replicates the API of multiprocessing but is no more than a wrapper around the threading module.

恍然大悟！！！如果分不清任务是CPU密集型还是IO密集型，我就用如下2个方法分别试：

#+BEGIN_SRC python
from multiprocessing import Pool
from multiprocessing.dummy import Pool
#+END_SRC

哪个速度快就用那个。从此以后我都尽量在写兼容的方式，这样在多线程/多进程之间切换非常方便。
** 相关模块
7. Queue。这个模块用于多线程编程，它是一个线程安全的FIFO（先进先出）的队列实现。如果是多进程编程，选用multiprocessing.queues中的Queue、SimpleQueue、JoinableQueue这三个队列实现。 
5. multiprocessing。多进程模块，这重要性就不说了。
10. threading。多线程模块，重要性也不必说。



* python 风格规范 google 开源项目
** 字符串


 即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定.

 Yes:
#+BEGIN_SRC python
  x = a + b
  x = '%s, %s!' % (imperative, expletive)
  x = '{}, {}!'.format(imperative, expletive)
  x = 'name: %s; score: %d' % (name, n)
  x = 'name: {}; score: {}'.format(name, n) 
#+END_SRC
 No:
#+BEGIN_SRC python
  x = '%s%s' % (a, b)  # use + in this case
  x = '{}{}'.format(a, b)  # use + in this case
  x = imperative + ', ' + expletive + '!'
  x = 'name: ' + name + '; score: ' + str(n)
#+END_SRC


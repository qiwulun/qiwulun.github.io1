<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>赵骥's Site (文章分类：reading)</title><link>https://qiwulun.github.io/</link><description></description><atom:link type="application/rss+xml" rel="self" href="https://qiwulun.github.io/categories/reading.xml"></atom:link><language>zh_cn</language><lastBuildDate>Sun, 05 Feb 2017 17:14:10 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>福柯“谱系学”及《知识考古学》</title><link>https://qiwulun.github.io/posts/fu-ke-pu-xi-xue-ji-zhi-shi-kao-gu-xue.html</link><dc:creator>Zhao JI</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/fu-ke-pu-xi-xue-ji-zhi-shi-kao-gu-xue.html#sec-1"&gt;福柯的谱系学（généalogie）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;




&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;福柯的谱系学（généalogie）&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
谱系学是福柯从尼采那里借用的概念。
&lt;/p&gt;


&lt;blockquote&gt;
&lt;p&gt;
要厘清福柯的谱系学是什么意思，必须首先理解他提出这个概念所针对的是西方现代的历史观，在《尼采、谱系学和历史》一文中他对西方形而上学的历史观提出了强烈的批判，他认为西方普通的历史学实际上引入一个超历史的视点，这种历史的作用是把多样性最终化约为单一的普遍时间，从而组合成一个完全自我封闭的总体，这种历史总是使人把过去的种种事件都和解为一个统一体。“这种历史带着世界的终极的眼光来看待过去的一些事物。这种历史学家的历史在时间之外寻找一个支点，并妄称其判断的基础是一种预示世界终极的客观性。然而，这种历史却假定存在了永恒真理、灵魂不朽以及始终自我同一的意识。“这种超历史视角所支配的，最终就是一种形而上学的历史。
&lt;/p&gt;

&lt;p&gt;
这就是为什么福柯拒绝把自己的工作称为历史研究。他在《必须保卫社会》这样来定义谱系学方法和立场：“谱系学，相对与把知识注册在专属科学权力的等级中的规划，是一项解放历史知识使其摆脱奴役的事业，也就是说它有能力对统一的、形式化的和科学的话语进行反抗和斗争。局部知识[……]的复兴反对科学和认识的等级化及其固有权力，这就是无序的、片断的谱系学的计划。[……]考古学，这是属于分析局部话语性的方法，以及从如此描述的局部话语性开始，使解脱出来的知识运转起来的谱系学策略。”简言之，福柯认为西方的现代历史学预设了时间的方向，表现了一种进步主义的历史观，试图在纷繁复杂的世界中确定和规划这个世界的先验起点及其目的。虽未明言，但是不难看出，福柯要挑战的知识体系和话语秩序的典型代表就是黑格尔式的哲学。谱系学是非整体化的，反对知识的等级和神性，反对进步主义，强调事物和历史变迁的偶然性。福柯不认为我们的知识是一个走向形而上的纯粹真理的线性过程，他重视的是，权力和各种偶然因素怎样构成了知识生成的现实可能性条件。例如福柯在《不正常的人》中提出，现代医学中的精神病学的发展与权力对家庭和人口的干预密不可分，随着权力对于家庭和卫生的控制，精神病学把人区分为正常的人和不正常的人。这个学科的起源并不是“关于人的真理”这样一个形而上学主题在现实世界的必然历史发展，而是基于一系列权力运作和知识生产的相互关系。
福柯的谱系学可以说是在敲打和破坏西方现代历史哲学的地基，成为所谓后现代思潮的重要概念之一。对这一概念勾画一个大致的轮廓也并不困难，中国的学者已经发表了不少相关的论文。然而，généalogie（谱系学）之命名还是让人感到困惑不已，无论在法汉字典还是在已有的翻译和介绍中，这个词大部分都被译为谱系学。另外还有一种翻译是系谱学，然而与其说系谱学是一种更加精细的翻译，不如说它表明了译者翻译généalogie这个概念时的焦虑：感觉谱系学这个词不对劲，但是又不知怎么办，于是采用系谱学的说法，使它与常用词汇保持一点距离，从而可以用定义的方式使这个词接纳与常见的意思看上去无关的内容。这种术语上的困惑导致了对这个概念理解上一些混乱，使我们难以做更精细的辨析。智河在《福柯系谱学探微》中说到：“要实现第一个任务（即追溯对象的出身)，首先要破除人们千百年来形成的关于“本质、“本源”、“同一”的幻想。“而张艳玲在《解读福柯：从“知识考古学”到“系谱学”》中则认为：“    20世纪70年代，福柯用“系谱学”（genealogy）替代了他的‘考古学’。‘系谱学’这一概念来自尼采，尼采用它来说明道德偏见的起源。福柯的“系谱学”也是关于起源的考察，系谱学的原义就是关于家族世系、血统关系和重要人物事迹的科学，也就是对事物的起源和演变过程的考察。它与考古学的性质并无不同，例如，二者都试图从微观的角度重新考察社会历史，都试图打断历史连续性的巨大链条，倡导非连续性或断续性。“应该说，这两位学者都认识到谱系学的特征在于反形而上学的历史进步观和连续性，强调人类社会进程中的断裂，但是对于谱系学如何对待“起源”问题却有分歧，这个混乱有一定的普遍性。谱系学，无论在中国还是西方，都是一门研究血统承继的学问，其目的就是确定一个家族是如何传承有序，其高贵的血缘如何连续不绝。然而，根据内维尔（Judith Revel）所编撰的《福柯辞典》，福柯的généalogie，“其目的绝非追溯时间的源流，从而建立起历史的连续性，相反，它是要恢复事件的特殊性。”这两个意思之间的关系就像福柯自己常常用的词：有一道裂缝。
&lt;/p&gt;

&lt;p&gt;
在Robert法语字典中，généalogie解释如下：1，祖先的相续关系建立起的血缘源流。2，研究家族的源头和血缘继承的学问。汉语里“谱系”的意思与之非常接近，这个词的翻译几乎完全是榫卯相对，都指的是记述和研究宗族世系或同类事物的历代系统。为什么福柯拒绝承认历史的连续性和继承关系，强调断裂和偶然，却使用了一个让我们更容易联想到连续性和继承关系的术语“谱系学”呢？这个问题不免让福柯的翻译者和研究者感到疑惑和纠结，我们看到，对福柯谱系学的研究文章虽然很多，但是却没有人就这个词本身说清楚为什么福柯要使用谱系学这个术语来替代历史学。
&lt;/p&gt;

&lt;p&gt;
如果摆脱汉语的翻译和字典的解释，直接考察这个西文词的构成本身，也许会给我们带来一些启发。Généalogie，是两个部分组成的，后面的alogie在西语中（英语中是logy）一般意味着“学问、知识和学科”，而前面的gene也是一个常用词根，源自拉丁、希腊词根【gen】（出生，血统，世系，根本）。意思是“出生，创始，新生”等等，《圣经》中的《创世纪》就是用的这个词根（Genèse ，英语是Genesis），当代科技中的“基因”就是gene的音译。Généalogie这个词的构形的原义应该是研究出生的学问。
&lt;/p&gt;

&lt;p&gt;
从这个词意出发，我们恐怕就不难理解福柯为什么从尼采那里借用这个概念了。事实上，无论在尼采还是福柯那里，谱系学都不是用来说明某种概念或话语的家谱是如何继承的，而是强调概念或话语是“如何出生的”。福柯在《尼采、谱系学和历史》一文中提到了尼采对Ursprung（一般译为起源）的两种用法，“第一种不加强调，而且它可以与其他术语例如Entstehung（出现）、 Herkunft（出身）, Abkunft（来源）, Geburt（诞生）替换使用。”但是另一种则与Herkunft（出身）产生了对立：“在《道德谱系学》的这一点上，尼采希望表明Herkunft和Ursprung两个词之间的这种对立是有价值的”。尼采认为Ursprung（起源）是虚幻骗人的东西，不过是人类试图给现实所发生的一切历史事实之上赋予一个合理化的形式，用同一个先验的进程来定义人类实际生活经验，这个东西可以是柏拉图的理念，或者是黑格尔的绝对精神。而福柯眼中的谱系学家则“倾听历史，而不是信奉形而上学，他就会发现事物背后‘有一个完全不同的东西’：那并非一种无时间的、本质的秘密，而是这样的一个秘密，即这些事物都没有本质，或者说，它们的本质都是一点点地从异己的形式中建构出来的。“福柯认为，西方现代的历史学虽然研究的是时间变化的事物，但是却在所谓背后的深层阐释中探寻一个不变的纯洁的本质（超历史），谱系学则强调“事件的出身”，而这个出身常常是不干净的，猥琐低微的。假使我们探究人类的根本出身的尽头，那里站立着一直长毛的猿猴。
&lt;/p&gt;

&lt;p&gt;
起源和出身在日常语言中的语义非常接近，无论在汉语还是在德语中，都是如此。当尼采和福柯把这两个观念对立起来的时候，他们所说的起源是一种特殊的起源，不是指事物在现实的具体境遇中是如何产生的，而是某种固定不变的真理——虚幻的理性建构，这种观念相信现实世界的起源是先验的观念，例如：善恶、道德、真理、拯救等等。而福柯所说的“出身”与日常的用法不同，不是在某个具体的个体上寻找某种可以把他归入某个种族的特征，说他是德国或者是中国人；而是在时间的变迁中发生的具体的有标志性的事件，这些标记本身是混杂的，构成复杂的网络，它们不能被归结为任何一种统一的性质和运动。举例说，“德国人说他们拥有双重灵魂，认为这样就已经深入解释了他们的复杂性；他们上了某种吉利数字的当，或者更恰当地说，他们试图掌握种族上的混杂，而实际上他们正是从这种混杂中产生出来的。”也就是说，当德国人试图通过这种方式确定统一的“我”的时候，就落入了陷阱——他们假装有一个统一的灵魂，其实每一个德国都与另一个德国人不同，他们的出身其实也各个不同，只是被穿上的虚幻的一件叫做“德国人“的衣服。
&lt;/p&gt;

&lt;p&gt;
在大家都认为有一个一致性的地方，谱系学家开始研究其来源和出身，拆解那个“我”，寻找到被人遗忘的种种纷繁复杂的事件的原貌。“谱系学被定义为对“出身”（Herkunft）和“出现”（Entstehung）进行的研究“，这个出身并不具有神一样的高贵的血统，也不代表任何“本质”，所有的事件都是在时间中不断地生成（générer）。这是一种否定连续性，打断继承性，强调异质性的谱系学，它不寻找一个统一的源头，而是分析不同事件在历史中所产生的效果。所以在某种意义上来说，福柯所说的谱系学恰恰是我们的日常语言中所说的谱系学的反面。为了避免日常语义的困扰和误导，陈雪虎先生提议干脆不要用谱系学来翻译généalogie，而是用”出生学“或者”出身学“，这样更准确，更能表达福柯的思想，同时能避免因词语造成的混乱。然而，站在译者的角度，我还是感到犹豫不定。因为造一个新词，确实可以澄清一些理解和思维上的混乱，但是会造成一个术语对应不同汉语词汇的情况，这在福柯的语境中也许没有问题，但是面对其他语境的时候，则有可能造成其他问题，使我们在进行概念的比较研究的时候，造成新的困难。而且，généalogie在西语的环境中，受到日常语义的干扰，对于欧洲人来说其实也可能引起误解，也需要通过详细的辨析和对词形的考查才能把握其特定涵义，那么在翻译到汉语的过程中是不是真的应该消除掉这个词的日常语义？恐怕这个问题对于哲学著作的翻译者来说，始终是纠结难解的问题。
&lt;/p&gt;


&lt;p&gt;
福柯谱系学与历史学的对立，其实中国学者的体会并不很深，也不敏感。原因并不在于中国 学者不能接受其谱系学，不能理解他所说的知识发生的经验性和历史的多变性，而是中国的 传统历史观本来就不太形而上学，更没有福柯视为对手的历史进步主义。网上有一个流传甚 广的黑格尔的名言：“中国没有真正的历史”。当然，黑格尔并没有这样说过，《历史哲学》 中的原话是：“这种历史的详细节目，我们用不着深入考究，因为这种历史本身既然没表现 出有何进展，只会阻碍我们历史的进步。”黑格尔式的形而上学历史观是现代才引入中国的 舶来品，传统上中国历史观与进步主义无关，没有什么超历史的视角，更没有对历史终结的 追求。知识产生于多方面的现实经验，来自可感知的千差万别的具体生活历史，历史并没有 一个终结和目标。福柯谱系学所强调的这些观念，对于中国传统来说，并没有什么格格不入
之处，甚至会感到一种特别的亲切。
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>reading</category><guid>https://qiwulun.github.io/posts/fu-ke-pu-xi-xue-ji-zhi-shi-kao-gu-xue.html</guid><pubDate>Sun, 05 Feb 2017 11:39:17 GMT</pubDate></item><item><title>effective python 阅读笔记1</title><link>https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html</link><dc:creator>Zhao JI</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-1"&gt;Chapter1: Pythonic Thinking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-2"&gt;Chapter        3:        Classes        and        Inheritance&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-2-1"&gt;Item        22:        Prefer        Helper        Classes        Over        Bookkeeping        with        Dictionaries        and        Tuples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-2-2"&gt;Item        23:        Accept        Functions        for        Simple        Interfaces        Instead        of        Classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-2-3"&gt;Item        1:        Know        Which        Version        of        Python        You’re        Using&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-2-4"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-3"&gt;Chapter        2: Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-4"&gt;Chapter        3:        Classes        and        Inheritance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-5"&gt;Chapter        4:        Metaclasses        and        Attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-6"&gt;Chapter        5:        Concurrency        and        Parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-7"&gt;Chapter        6:        Built-in        Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-8"&gt;Chapter        7:        Collaboration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html#sec-9"&gt;Chapter        8:        Production&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;a href="http://www.effectivepython.com"&gt;http://www.effectivepython.com&lt;/a&gt;
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Chapter1: Pythonic Thinking&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
The Python community has come to use the adjective Pythonic to describe code
that follows a particular style. The idioms of Python have emerged over time
through experience using the language and working with others. This chapter
covers the best way to do the most common things in Python.
Item        1:        Know        Which        Version        of        Python        You’re        Using
Item        2:        Follow        the        PEP        8        Style        Guide
Item        3:        Know        the        Differences        Between        bytes,        str,        and        unicode
Item        4:        Write        Helper        Functions        Instead        of        Complex        Expressions
Item        5:        Know        How        to        Slice        Sequences
Item        6:        Avoid        Using        start,        end,        and        stride        in        a        Single        Slice
Item        7:        Use        List        Comprehensions        Instead        of        map        and        filter
Item        8:        Avoid        More        Than        Two        Expressions        in        List        Comprehensions
Item        9:        Consider        Generator        Expressions        for        Large        Comprehensions
Item        10:        Prefer        enumerate        Over        range
Item        11:        Use        zip        to        Process        Iterators        in        Parallel
Item        12:        Avoid        else        Blocks        After        for        and        while        Loops
Item        13:        Take        Advantage        of        Each        Block        in        try/except/else/finally 
Item        14:        Prefer        Exceptions        to        Returning        None
Item        15:        Know        How        Closures        Interact        with        Variable        Scope
Item        16:        Consider        Generators        Instead        of        Returning        Lists
Item        17:        Be        Defensive        When        Iterating        Over        Arguments
Item        18:        Reduce        Visual        Noise        with        Variable        Positional        Arguments
Item        19:        Provide        Optional        Behavior        with        Keyword        Arguments
Item        20:        Use        None        and        Docstrings        to        Specify        Dynamic        Default        Arguments
Item        21:        Enforce        Clarity        with        Keyword-Only        Arguments
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;Chapter        3:        Classes        and        Inheritance&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;&lt;div id="outline-container-sec-2-1" class="outline-3"&gt;
&lt;h3 id="sec-2-1"&gt;Item        22:        Prefer        Helper        Classes        Over        Bookkeeping        with        Dictionaries        and        Tuples&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Avoid        making        dictionaries        with        values        that        are        other        dictionaries        or        long        tuples.
&lt;/li&gt;
&lt;li&gt;Use        namedtuple        for        lightweight,        immutable        data        containers        before        you        need        the
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
flexibility        of        a        full        class.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Move        your        bookkeeping        code        to        use        multiple        helper        classes        when        your        internal        state
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
dictionaries        get        complicated.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-2" class="outline-3"&gt;
&lt;h3 id="sec-2-2"&gt;Item        23:        Accept        Functions        for        Simple        Interfaces        Instead        of        Classes&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
Item        24:        Use        @classmethod        Polymorphism        to        Construct        Objects        GenericallyItem        25:        Initialize        Parent        Classes        with        super
Item        26:        Use        Multiple        Inheritance        Only        for        Mix-in        Utility        Classes
Item        27:        Prefer        Public        Attributes        Over        Private        Ones
Item        28:        Inherit        from        collections.abc        for        Custom        Container        Types
Chapter        4:        Metaclasses        and        Attributes
Item        29:        Use        Plain        Attributes        Instead        of        Get        and        Set        Methods
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Define        new        class        interfaces        using        simple        public        attributes,        and        avoid        set        and        get
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
methods.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Use        @property        to        define        special        behavior        when        attributes        are        accessed        on        your
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
objects,        if        necessary.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Follow        the        rule        of        least        surprise        and        avoid        weird        side        effects        in        your        @property
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
methods.
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Ensure        that        @property        methods        are        fast;        do        slow        or        complex        work        using        normal
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
methods.
Item        30:        Consider        @property        Instead        of        Refactoring        Attributes
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;I        especially        like        @property        because        it        lets        you        make        incremental        progress        toward        a better        data        model        over        time.        Reading        the        Bucket        example        above,        you        may        have        thought to        yourself,        “fill        and        deduct        should        have        been        implemented        as        instance        methods        inthe        first        place.”        Although        you’re        probably        right        (see        Item        22:        “Prefer        Helper        Classes        Over Bookkeeping        with        Dictionaries        and        Tuples”),        in        practice        there        are        many        situations        in which        objects        start        with        poorly        defined        interfaces        or        act        as        dumb        data        containers.        This happens        when        code        grows        over        time,        scope        increases,        multiple        authors        contribute        without anyone        considering        long-term        hygiene,        etc. @property        is        a        tool        to        help        you        address        problems        you’ll        come        across        in        real-world code.        Don’t        overuse        it.        When        you        find        yourself        repeatedly        extending        @property methods,        it’s        probably        time        to        refactor        your        class        instead        of        further        paving        over        your code’s        poor        design.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Item        31:        Use        Descriptors        for        Reusable        @property        Methods
Item        32:        Use        &lt;span class="underline"&gt;&lt;span class="underline"&gt;getattr&lt;/span&gt;&lt;/span&gt;,        &lt;span class="underline"&gt;&lt;span class="underline"&gt;getattribute&lt;/span&gt;&lt;/span&gt;,        and        &lt;span class="underline"&gt;&lt;span class="underline"&gt;setattr&lt;/span&gt;&lt;/span&gt; for        Lazy
Attributes
Item        33:        Validate        Subclasses        with        Metaclasses
Item        34:        Register        Class        Existence        with        Metaclasses
Item        35:        Annotate        Class        Attributes        with        Metaclasses
Chapter        5:        Concurrency        and        Parallelism
Item        36:        Use        subprocess        to        Manage        Child        Processes
Item        37:        Use        Threads        for        Blocking        I/O,        Avoid        for        Parallelism
Item        38:        Use        Lock        to        Prevent        Data        Races        in        Threads
Item        39:        Use        Queue        to        Coordinate        Work        Between        Threads
Item        40:        Consider        Coroutines        to        Run        Many        Functions        Concurrently
Item        41:        Consider        concurrent.futures        for        True        Parallelism
Chapter        6:        Built-in        Modules
Item        42:        Define        Function        Decorators        with        functools.wraps
Item        43:        Consider        contextlib        and        with        Statements        for        Reusable        try/finally
Behavior
Item        44:        Make        pickle        Reliable        with        copyreg
Item        45:        Use        datetime        Instead        of        time        for        Local        Clocks
Item        46:        Use        Built-in        Algorithms        and        Data        Structures
Item        47:        Use        decimal        When        Precision        Is        Paramount
Item        48:        Know        Where        to        Find        Community-Built        Modules
Chapter        7:        Collaboration
Item        49:        Write        Docstrings        for        Every        Function,        Class,        and        Module
Item        50:        Use        Packages        to        Organize        Modules        and        Provide        Stable        APIsItem        51:        Define        a        Root        Exception        to        Insulate        Callers        from        APIs
Item        52:        Know        How        to        Break        Circular        Dependencies
Item        53:        Use        Virtual        Environments        for        Isolated        and        Reproducible        Dependencies
Chapter        8:        Production
Item        54:        Consider        Module-Scoped        Code        to        Configure        Deployment        Environments
Item        55:        Use        repr        Strings        for        Debugging        Output
Item        56:        Test        Everything        with        unittest
Item        57:        Consider        Interactive        Debugging        with        pdb
Item        58:        Profile        Before        Optimizing
Item        59:        Use        tracemalloc        to        Understand        Memory        Usage        and        Leaks
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-2-3" class="outline-3"&gt;
&lt;h3 id="sec-2-3"&gt;Item        1:        Know        Which        Version        of        Python        You’re        Using&lt;/h3&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-4" class="outline-3"&gt;
&lt;h3 id="sec-2-4"&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Python’s syntax makes it all too easy to write single-line expressions that
are overly complicated and difficult to read.
&lt;/li&gt;
&lt;li&gt;Move complex expressions into helper functions, especially if you need to use
the same logic repeatedly.
&lt;/li&gt;
&lt;li&gt;The if/else expression provides a more readable alternative to using Boolean
operators like or and and in expressions.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;Chapter        2: Functions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Functions in Python have a variety of extra features that make a programmer’s
life easier. Some are similar to capabilities in other programming languages,
but many are unique to Python. This chapter covers how to use functions to
clarify intention, promote reuse, and reduce bugs.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;Chapter        3:        Classes        and        Inheritance&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
Python is an object-oriented language. Getting things done in Python often
requires writing new classes and defining how they interact through their
interfaces and hierarchies. This chapter covers how to use classes and
inheritance to express your intended behaviors with objects.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;Chapter        4:        Metaclasses        and        Attributes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
Metaclasses and dynamic attributes are powerful Python features. However, they
also enable you to implement extremely bizarre and unexpected behaviors. This
chapter covers the common idioms for using these mechanisms to ensure that you
follow the rule of least surprise.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-6" class="outline-2"&gt;
&lt;h2 id="sec-6"&gt;Chapter        5:        Concurrency        and        Parallelism&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
Python        makes        it        easy        to        write        concurrent        programs        that        do        many        different        things
seemingly        at        the        same        time.        Python        can        also        be        used        to        do        parallel        work        through        system
calls,        subprocesses,        and        C-extensions.        This        chapter        covers        how        to        best        utilize        Python        in
these        subtly        different        situations.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7" class="outline-2"&gt;
&lt;h2 id="sec-7"&gt;Chapter        6:        Built-in        Modules&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;p&gt;
Python        is        installed        with        many        of        the        important        modules        that        you’ll        need        to        write        programs.
These        standard        packages        are        so        closely        intertwined        with        idiomatic        Python        that        they        may        as
well        be        part        of        the        language        specification.        This        chapter        covers        the        essential        built-in
modules.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-8" class="outline-2"&gt;
&lt;h2 id="sec-8"&gt;Chapter        7:        Collaboration&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;p&gt;
Collaborating        on        Python        programs        requires        you        to        be        deliberate        about        how        you        write        your
code.        Even        if        you’re        working        alone,        you’ll        want        to        understand        how        to        use        modules        written
by        others.        This        chapter        covers        the        standard        tools        and        best        practices        that        enable        people        to
work        together        on        Python        programs.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-9" class="outline-2"&gt;
&lt;h2 id="sec-9"&gt;Chapter        8:        Production&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-9"&gt;
&lt;p&gt;
Python        has        facilities        for        adapting        to        multiple        deployment        environments.        It        also        has        built-in
modules        that        aid        in        hardening        your        programs        and        making        them        bulletproof.        This        chapter
covers        how        to        use        Python        to        debug,        optimize,        and        test        your        programs        to        maximize        quality
and        performance        at        runtime.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>books</category><category>reading</category><guid>https://qiwulun.github.io/posts/effective-python-yue-du-bi-ji-1.html</guid><pubDate>Sat, 24 Dec 2016 06:21:19 GMT</pubDate></item></channel></rss>